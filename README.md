# gRPC 

- [Загальні поняття](#загальні-поняття)
  - [RPC](#rpc)
  - [HTTP/2](#http2)
  - [gRPC](#grpc-1)
  - [Використання gRPC](#використання-grpc)

# Загальні поняття

### RPC
RPC (Remote procedure call) - протокол, що дозволяє програмі, запущеній на одному комп'ютері, звертатись до функцій (процедур) програми, що виконується на іншому комп'ютері, подібно до того, як програма звертається до власних локальних функцій. 

RPC працює за принципом протоколів "запит-відповідь" . Виклик ініціюється клієнтом, що надсилає повідомлення віддаленого сервера з запитом щодо виконання заданої процедури з деякими параметрами. Віддалений сервер надсилає відповідь до клієнта і додаток продовжує процесс, що обробляє відповідь. Поки сервер оброблює відповідь, клієнт заблокований (він чекає поки сервер завершить свій процес, перед тим як відновити виконання своєї задачі), якщо тільки не викликається асинхронний запит з клієнта.

![client-server](images/client-server.png)

### Послідовність подій

1. Клієнт викликає клієнтський стаб. Робиться виклик локальної процедури, під час якої параметри записується у стек.
2. Стаб (або заглушка) клієнта готує виклик шляхом упаковки параметрів до виклику процедури. (Цей процес називається маршалінгом)
3. Локальна операційна система клієнта надсилає повідомлення з клієнтської машини до сервера.
3. Локальна операційна система сервера передає прийняті пакети до стабу сервера.
4. Стаб сервера розпаковує параметри з повідомлення (Цей процес називається демаршалінгом).
5. Наприкінці, серверний стаб викликає процедуру на сервері. Відповідь формується та надсилається за цією ж послідовністю, але у зворотньому напрямку.

### HTTP/2

HTTP/2 — це друга основна версія протоколу HTTP, яка була офіційно затверджена в 2015 році [RFC 9113](https://www.rfc-editor.org/rfc/rfc9113). Вона значно покращує продуктивність порівняно з HTTP/1.1, особливо у швидкості завантаження веб-сторінок та ефективності використання мережевих ресурсів.

Особливості HTTP/2:

**Мультиплексування**

HTTP/2 дозволяє передавати кілька запитів та відповідей одночасно по одному TCP-з'єднанню. Це частково усуває проблему блокування запитів у HTTP/1.1 (Head-of-line blocking).

![multiplexing](images/http2/multiplexing.png)

**Бінарний протокол**

HTTP/2 використовує бінарний формат замість текстового (як у HTTP/1.1), що зменшує накладні витрати на парсинг і покращує ефективність передачі даних.

![binary-format](images/http2/binary-format.png)

**Стиск заголовків (HPACK)**

HTTP/2 стискає HTTP-заголовки за допомогою спеціального алгоритму HPACK, що значно зменшує обсяг переданої інформації.

![hpack](images/http2/hpack.png)

**Server Push**

Сервер може відправляти ресурси клієнту ще до того, як клієнт їх запросив. Це допомагає зменшити затримки у завантаженні сторінки.

![server push](images/http2//server-push.png)

**Пріоритизація запитів**

HTTP/2 дозволяє вказувати пріоритетність запитів, що допомагає оптимізувати порядок їхньої обробки.

![prioritizing](images/http2/prioritizing.png)

**Одне з'єднання на домен**

На відміну від HTTP/1.1, який відкривав кілька TCP-з'єднань для паралельних запитів, HTTP/2 використовує лише одне з'єднання на домен, що зменшує накладні витрати на встановлення з'єднань.

![one-connection](images/http2/one-connection.png)

### gRPC

gRPC (Google Remote Procedure Call) - це система віддаленого виклику процедур (RPC) з відкритим кодом, початково розроблена в Google у 2015 році як наступне покоління інфраструктури RPC Stubby. 

**Особливості gRPC**

gRPC використовує HTTP/2 як транспортний протокол. HTTP/2 забезпечує більш ефективне використання мережевих ресурсів у порівнянні з HTTP/1.1, дозволяючи безлічі запитів та відповідей передаватися паралельно в рамках одного TCP-з'єднання. Це зменшує затримки та збільшує загальну продуктивність.

gRPC використовує Protocol Buffers, мову опису інтерфейсів та систему серіалізації від Google, як формат для структурування даних. ProtoBuf дозволяє визначати структуру даних та інтерфейси сервісів у спеціальних файлах `.proto`. Ці файли компактні, ефективні та дозволяють автоматично генерувати вихідний код для різних мов програмування.

ProtoBuf серіалізує структуровані дані у менший обсяг у порівнянні з такими форматами, як JSON або XML. Це зменшує розміри пакетів даних, прискорюючи їх передачу та обробку. Про ProtoBuf докладніше трохи пізніше.

Приклад `.proto` файлу
```proto
// Визначення версії синтаксиса ProtoBuf
syntax = "proto3";

// Визначення повідомлення User
message User {
  int32 id = 1;
  string name = 2;
  string email = 3;
  repeated string roles = 4;
}

// Визначення запиту для отримання інформації про користувача
message GetUserRequest {
  int32 user_id = 1;
}

// Визначення відповіді, що містить інформацію про користувача
message GetUserResponse {
  User user = 1;
}

// Визначення сервіса UserService
service UserService {
  // Визначення метода для отримання інформації про користувача
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
```

gRPC підтримує кілька типів взаємодій:

- **Unary RPC**: Це базова і проста модель в gRPC. Клієнт відправляє один запит серверу та отримує у відповідь одне повідомлення. Це аналогічно до традиційного виклику функції в програмуванні. Підходить для простих запитів та операцій, де потрібна одноразова взаємодія, наприклад, отримання інформації щодо ідентифікатора або надсилання даних для обробки.

- **Server streaming RPC**: У цій моделі клієнт надсилає один запит серверу, після чого сервер починає надсилати потік відповідей. Клієнт читає відповіді з їх надходження, що може тривати невизначений час. Дуже добре підходить для сценаріїв, де сервер повинен надіслати велику кількість даних або постійно оновлювану інформацію, наприклад, при передачі логів або потокової передачі даних.

- **Client streaming RPC**: У цій моделі клієнт надсилає потік даних серверу. Після завершення відправки потоку клієнт чекає на відповідь від сервера. Сервер обробляє весь потік даних, перш ніж надіслати одну відповідь. Цей тип підходить для сценаріїв, де клієнту необхідно надіслати велику кількість даних або серію повідомлень, наприклад, під час завантаження великих файлів або пакетної обробки даних.

- **Bidirectional streaming RPC**: У двонаправленому потоковому RPC клієнт та сервер обмінюються потоками даних в обох напрямках. Клієнт може розпочати відправлення серії повідомлень, не чекаючи відповіді сервера, і навпаки. Цей тип RPC найбільш гнучкий і підходить для складних взаємодій, де клієнт та сервер повинні активно обмінюватися даними в реальному часі, наприклад, в інтерактивних програмах, чатах або системах реального часу.

**Канал в gRPC**

Канал gRPC забезпечує підключення до сервера gRPC на вказаному хості та порту. Використовується при створенні заглушки клієнта. Клієнти можуть вказати аргументи каналу, щоб змінити поведінку gRPC за замовчуванням, наприклад увімкнути або вимкнути стиснення повідомлень. Канал має стан, `connected` та `idle`.

**Deadlines/Timeouts**

gRPC дозволяє клієнтам вказати, як довго вони готові чекати завершення RPC, перш ніж RPC завершиться з помилкою DEADLINE_EXCEEDED. На стороні сервера сервер може запитувати, чи минув час очікування певного RPC або скільки часу залишилося для завершення RPC.

### Використання gRPC

**Мікросервісна архітектура**

gRPC ідеально підходить для побудови мікросервісів, де необхідна ефективна комунікація між сервісами. Використовується для реалізації сервісів, які працюють на різних мовах програмування (наприклад, один сервіс на Go, інший на Python).

**Високонавантажені системи**

Завдяки використанню HTTP/2, gRPC забезпечує високу продуктивність і низьку затримку, що робить його ідеальним для систем з великою кількістю запитів (наприклад, фінансові системи, IoT, ігрові сервери).

**Реальний час (Real-time systems)**

gRPC підтримує двонаправлену потокову передачу даних, що дозволяє реалізовувати системи реального часу, такі як чати, онлайн-ігри або системи моніторингу.

**Мобільні додатки**

gRPC часто використовується для комунікації між мобільними додатками і серверами через його ефективність і компактність.

**Розподілені системи**

gRPC забезпечує надійну та швидку комунікацію між компонентами розподілених систем. Завдяки підтримці потоковій передачі даних можна ефективно обробляти великі обсяги інформації.